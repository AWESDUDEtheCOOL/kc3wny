import fs from 'node:fs'
import path from 'node:path'

export type ImageMetadata = {
  width: number
  height: number
  blurDataUrl: string
}

// In-memory cache for the current build
const memoryCache = new Map<string, ImageMetadata>()

// Pre-generated blur cache (loaded from .blur-cache.json)
let blurCache: Record<string, ImageMetadata & { mtime?: number }> | null = null

/**
 * Load the pre-generated blur cache from disk.
 * This cache is generated by scripts/generate-blur-placeholders.js
 */
function loadBlurCache(): Record<string, ImageMetadata & { mtime?: number }> {
  if (blurCache !== null) return blurCache

  try {
    const cachePath = path.join(process.cwd(), '.blur-cache.json')
    if (fs.existsSync(cachePath)) {
      blurCache = JSON.parse(fs.readFileSync(cachePath, 'utf8'))
      return blurCache as Record<string, ImageMetadata & { mtime?: number }>
    }
  } catch (error) {
    console.warn('Could not load blur cache:', error)
  }
  
  blurCache = {}
  return blurCache
}

/**
 * Get blur placeholder and metadata for an image.
 * Uses pre-generated cache for fast builds.
 * Falls back to generating on-demand if cache miss (development).
 */
export async function getImageBlurData(imagePath: string): Promise<ImageMetadata | null> {
  // Normalize path separators for consistent cache keys
  const normalizedPath = imagePath.replace(/\\/g, '/')
  
  // Check memory cache first
  const memoryCached = memoryCache.get(normalizedPath)
  if (memoryCached) return memoryCached

  // Check pre-generated blur cache
  const cache = loadBlurCache()
  const cached = cache[normalizedPath]
  if (cached) {
    const result: ImageMetadata = {
      width: cached.width,
      height: cached.height,
      blurDataUrl: cached.blurDataUrl,
    }
    memoryCache.set(normalizedPath, result)
    return result
  }

  // Cache miss - generate on-demand (slower, for dev or new images)
  // Only import sharp if we actually need to generate
  try {
    const { default: sharp } = await import('sharp')
    const fullPath = path.join(process.cwd(), 'content', imagePath)
    
    if (!fs.existsSync(fullPath)) {
      console.error(`Image not found: ${fullPath}`)
      return null
    }

    const fileBuffer = fs.readFileSync(fullPath)
    const sharpImage = sharp(fileBuffer)
    const metadata = await sharpImage.metadata()
    
    // Handle EXIF orientation
    let width = metadata.width || 800
    let height = metadata.height || 600
    if (metadata.orientation && metadata.orientation >= 5 && metadata.orientation <= 8) {
      [width, height] = [height, width]
    }
    
    // Generate a tiny blurred placeholder (10px wide)
    const blurredBuffer = await sharp(fileBuffer)
      .rotate()
      .resize(10, null, { withoutEnlargement: true })
      .blur(2)
      .jpeg({ quality: 50 })
      .toBuffer()
    
    const blurDataUrl = `data:image/jpeg;base64,${blurredBuffer.toString('base64')}`
    
    const result: ImageMetadata = { width, height, blurDataUrl }
    memoryCache.set(normalizedPath, result)
    
    // Log warning in dev to encourage running the cache script
    if (process.env.NODE_ENV === 'development') {
      console.warn(`⚠️  Blur cache miss for "${normalizedPath}". Run: node scripts/generate-blur-placeholders.js`)
    }
    
    return result
  } catch (error) {
    console.error('Failed to generate blur data:', error)
    return null
  }
}

/**
 * Extract the content path from an API image URL
 */
export function getContentPathFromSrc(src: string): string | null {
  if (src.startsWith('/api/content-image')) {
    try {
      const url = new URL(src, 'http://localhost')
      return url.searchParams.get('path')
    } catch {
      return null
    }
  }
  return null
}
